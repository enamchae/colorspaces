import { InSocket, Node, NodeOutputTarget, NodeUpdateSource, OutSocket, Socket, SocketType, webglOuts } from "@/models/Node";
import { webglDeclarations } from "@/models/colormanagement";
import { objectSymbolEntries, objectSymbolValues } from "@/util";

export class WebglModule {
  constructor(
    private readonly template: string,
    private readonly dependencies: WebglModule[] = [],
  ) {}
}

export class WebglSlot {
  private constructor(
    /** Determines whether this slot will receive a value to be filled later (input) or will provide a value that
     * results from a template's code (output). Output slots will be automatically filled with an autogenerated
     * variable name when found in a template passed to `WebglVariables.fromTemplate`.
     */
    readonly isInput: boolean,
    readonly identifier: string,
  ) {}

  static in(identifier: string) {
    return new WebglSlot(true, identifier);
  }

  static out(identifier: string) {
    return new WebglSlot(false, identifier);
  }
    
  static ins<S extends readonly string[]>(...identifiers: S): SlotMap<S> {
    return Object.fromEntries(identifiers.map(identifier => [identifier, WebglSlot.in(identifier)])) as SlotMap<S>;
  }
    
  static outs<S extends readonly string[]>(...identifiers: S): SlotMap<S>  {
    return Object.fromEntries(identifiers.map(identifier => [identifier, WebglSlot.out(identifier)])) as SlotMap<S>;
  }

  get isOutput(): boolean {
    return !this.isInput;
  }

  randomVariableName() {
    return `v_${this.identifier.replaceAll(/ |[^a-zA-Z0-9]/g, "_")}_${crypto.randomUUID().replaceAll("-", "_")}`;
  }
}

type SlotMap<S extends readonly string[]=any> = Record<S[number], WebglSlot>;

/** Stores chunks of WebGL code, between them macro-like variable slots to insert values into, as well as the values
 * which the slots have been assigned. */
export class WebglTemplate<InputSlots extends SlotMap=any, OutputSlots extends SlotMap=any> {
  private constructor(
    private readonly segments: TemplateStringsArray,
    private readonly inputSlots: InputSlots,
    private readonly outputSlots: OutputSlots,
    private readonly slots: WebglSlot[],
    readonly substitutions: Map<WebglSlot, string>=new Map(),
  ) {}

  static source(segments: TemplateStringsArray, ...slots: WebglSlot[]): WebglTemplate {
    const inputSlots: SlotMap = {};
    const outputSlots: SlotMap = {};
    for (const slot of slots) {
      if (slot.isInput) {
        inputSlots[slot.identifier] = slot;
      } else {
        outputSlots[slot.identifier] = slot;
      }
    }

    return new WebglTemplate(segments, inputSlots, outputSlots, slots);
  }

  static concat(segments: TemplateStringsArray, ...items: (WebglSlot | WebglTemplate | string)[]): WebglTemplate {
    const templates: WebglTemplate[] = [];

    let currentSegments: string[] = [segments[0]];
    let currentSegmentsRaw: string[] = [segments.raw[0]];
    let currentSlots: WebglSlot[] = [];

    const pushCode = () => {
      templates.push(WebglTemplate.source(Object.assign(currentSegments, {raw: currentSegmentsRaw}), ...currentSlots));
    };

    for (let i = 1; i < segments.length; i++) {
      const segment = segments[i];
      const segmentRaw = segments.raw[i];
      const item = items[i - 1];

      if (item instanceof WebglTemplate) {
        pushCode();
        currentSegments = [segment];
        currentSegmentsRaw = [segmentRaw];
        currentSlots = [];
        
        templates.push(item);
      } else if (typeof item === "string") {
        currentSegments[currentSegments.length - 1] += `${item}${segment}`;
        currentSegmentsRaw[currentSegmentsRaw.length - 1] += `${item}${segmentRaw}`;
      } else {
        currentSlots.push(item);
        currentSegments.push(segment);
        currentSegmentsRaw.push(segmentRaw);
      }
    }

    pushCode();

    return WebglTemplate.merge(...templates);
  }

  /** Creates a template consisting of just a slot. */
  static slot(slot: WebglSlot): WebglTemplate {
    return WebglTemplate.source`${slot}`;
  }

  static string(string: string) {
    return new WebglTemplate(Object.assign([string], {raw: [string]}), {}, {}, []);
  }

  static empty() {
    return WebglTemplate.string("");
  }

  static merge(...templates: WebglTemplate[]) {
    const newSegments: string[] = [];
    const newSegmentsRaw: string[] = [];
    for (const [templateIndex, template] of templates.entries()) {
      for (const [segmentIndex, segment] of template.segments.entries()) {
        const segmentRaw = template.segments.raw[segmentIndex];
        
        if (segmentIndex === 0 && templateIndex > 0) {
          newSegments[newSegments.length - 1] += segment;
          newSegmentsRaw[newSegmentsRaw.length - 1] += segmentRaw;
          continue;
        }

        newSegments.push(segment);
        newSegmentsRaw.push(segmentRaw);
      }
    }

    return new WebglTemplate(
      Object.assign(newSegments, {raw: newSegmentsRaw}),
      templates.reduce((acc, template) => Object.assign(acc, template.inputSlots), {}),
      templates.reduce((acc, template) => Object.assign(acc, template.outputSlots), {}),
      templates.flatMap(template => template.slots),
      new Map(templates.flatMap(template => [...template.substitutions])),
    );
  }

  substitute(substitutions: Map<WebglSlot, string>) {
    return new WebglTemplate(
      this.segments,
      this.inputSlots,
      this.outputSlots,
      this.slots,
      new Map([...this.substitutions, ...substitutions]),
    );
  }

  substituteInputs(getSubstitutions: (inputSlots: InputSlots) => Map<WebglSlot, string>) {
    return this.substitute(getSubstitutions(this.inputSlots));
  }

  static substitutionsUsingOutputs(outputs: WebglOutputs, outputMapping: WebglOutputMapping) {
    const substitutions = new Map<WebglSlot, string>();
    for (const [key, slot] of objectSymbolEntries(outputMapping)) {
      const template = outputs[key];
      if (!template) throw new TypeError(`Attempted to map an output variable "${key.description}", which does not exist on the given outputs`);

      substitutions.set(slot as WebglSlot, template.toString());
    }
    return substitutions;
  }

  substituteUsingOutputs(outputs: WebglOutputs, outputMapping: WebglOutputMapping) {
    return this.substitute(WebglTemplate.substitutionsUsingOutputs(outputs, outputMapping));
  }

  toString() {
    return `${this.segments[0]}${this.slots.map((slot, i) => {
      if (!this.substitutions.has(slot)) {
        throw new Error(`Not all input slots are filled: ${
          Object.values(this.inputSlots)
              .filter(slot => !this.substitutions.has(slot))
              .map(slot => slot.identifier)
              .join(", ")
        }`);
      }

      return `${this.substitutions.get(slot)}${this.segments[i + 1]}`;
    }).join("")}`;
  }

  static withSlots<IIdentifiers extends readonly string[], OIdentifiers extends readonly string[]>(
    inputSlotIdentifiers: IIdentifiers,
    outputSlotIdentifiers: OIdentifiers,
    build: (
      inputSlots: SlotMap<IIdentifiers>,
      outputSlots: SlotMap<OIdentifiers>,
    ) => WebglTemplate<SlotMap<IIdentifiers>, SlotMap<OIdentifiers>>,
  ): WebglTemplate<SlotMap<IIdentifiers>, SlotMap<OIdentifiers>> {
    return build(WebglSlot.ins(...inputSlotIdentifiers), WebglSlot.outs(...outputSlotIdentifiers));
  }

  getOutputSlots() {
    return Object.values(this.outputSlots);
  }

  getInputSlot(identifier: string): WebglSlot {
    return this.inputSlots[identifier];
  }
}


type UniformInitializer = {
  set(gl: WebGL2RenderingContext, unif: WebGLUniformLocation | null, nUsedTextures: number): boolean | void,
  dependencySockets: InSocket[],
  /** For when a dependency is a `NodeSpecialInput` */
  dependencyNodes: Node[],
};

export type WebglOutputs = Partial<Record<symbol, WebglTemplate>>;
export type WebglOutputMapping = Partial<Record<symbol, WebglSlot>>;

/** Stores a chunk of GLSL code with macro-like slots for variables. */
export class WebglVariables {
  static readonly fragmentShaderTemplate = WebglTemplate.withSlots(
    ["prelude", "main", "val", "illuminant", "xyz", "alpha"],
    [],
    (
      {prelude, main, val, illuminant, xyz, alpha},
      {},
    ) => WebglTemplate.concat`#version 300 es

#define PI 3.1415926538
#define REV 6.2831853071

precision mediump float;

struct Color {
  vec3 val;
  vec2 illuminant;
  vec3 xyz;
};

struct AlphaColor {
  Color color;
  float alpha;
};

in vec2 v_uv;
out vec4 fragColor;

uniform float outOfGamutAlpha;

${webglDeclarations}

${prelude}

AlphaColor sampleColor(vec2 coords) {
  ${main}
  
  return AlphaColor(Color(${val}, ${illuminant}, ${xyz}), ${alpha});
}

void main() {
  AlphaColor outColor = sampleColor(v_uv);
  vec3 outRgb = xyzToGammaSrgb(outColor.color.xyz, outColor.color.illuminant);

  float alpha = outColor.alpha;

  if (outOfGamutAlpha != 1.) {
    bool outOfGamut = -0.0001 > outRgb.r || outRgb.r > 1.0001
        || -0.0001 > outRgb.g || outRgb.g > 1.0001
        || -0.0001 > outRgb.b || outRgb.b > 1.0001;
  
    if (outOfGamut) {
      alpha *= outOfGamutAlpha;
    }
  }

  fragColor = vec4(outRgb, alpha);
}`,
  );

  static readonly auxiliaryFunctionTemplate = WebglTemplate.withSlots(
    ["outputType", "functionName", "main", "functionOutput"],
    [],
    (
      {outputType, functionName, main, functionOutput},
      {},
    ) => WebglTemplate.source`${outputType} ${functionName}(vec2 coords) {
  ${main}
  
  return ${functionOutput};
}`,
  );

  private constructor(
    /** The node which this object uses to obtain `WebglOutputs` objects from. */
    private readonly node: Node | null,
    /** The GLSL code that takes in GLSL variables and computes new ones. Templates may include "slots" for other GLSL
     * code or GLSL variables to be inserted.
     */
    readonly template: WebglTemplate,
    /** A template that declares variables in the prelude, which is inserted after the main body has been produced.
     * Usually used for declaring new uniforms.
     */
    private readonly preludeTemplate: WebglTemplate=WebglTemplate.empty(),
    /** The names of uniforms, mapped to functions to initialize those uniforms. */
    private readonly uniforms: Map<WebglTemplate, UniformInitializer>=new Map(),
    /** The names of functions, mapped to sockets whose incoming data will be accessible by those functions rather than
     * from a separate variable defined inside the template. One use case is the Sample node, which needs to be able to
     * evaluate the input socket be evaluated at multiple different coordinates.
     */
    private readonly functionInputDependencies: Map<WebglTemplate, OutSocket>=new Map(),
    private readonly fieldOutputs: WebglOutputs,
  ) {}

  /** Fills in the given slots with strings. */
  substitute(substitutions: Map<WebglSlot, string>) {
    const uniforms: WebglVariables["uniforms"] = new Map(this.uniforms);
    const functionDependencies: WebglVariables["functionInputDependencies"] = new Map(this.functionInputDependencies);

    const template = this.template.substitute(substitutions);
    const preludeTemplate = this.preludeTemplate.substitute(substitutions);

    const newUniforms = new Map(uniforms);
    for (const [uniformNameTemplate, value] of uniforms) {
      newUniforms.delete(uniformNameTemplate);
      newUniforms.set(uniformNameTemplate.substitute(substitutions), value);
    }

    const newFunctionDependencies = new Map(functionDependencies);
    for (const [functionNameTemplate, value] of functionDependencies) {
      newFunctionDependencies.delete(functionNameTemplate);
      newFunctionDependencies.set(functionNameTemplate.substitute(substitutions), value);
    }

    const newFieldOutputs: WebglOutputs = {};
    for (const [key, template] of objectSymbolEntries(this.fieldOutputs)) {
      newFieldOutputs[key] = template!.substitute(substitutions);
    }

    return new WebglVariables(this.node, template, preludeTemplate, newUniforms, newFunctionDependencies, newFieldOutputs);
  }

  substituteUsingOutputs(
    outputs: WebglOutputs,
    outputMapping: WebglOutputMapping,
  ) {
    return this.substitute(WebglTemplate.substitutionsUsingOutputs(outputs, outputMapping));
  }

  /**
   * 
   * @param source 
   * @param outputTarget 
   * @param outputMapping Map that tells into which input slots in `this` to route the value of each output
   * slot in the `source`
   * @param keepSourcePrelude 
   * @returns 
   */
  substituteUsingOutputsFrom(
    source: WebglVariables,
    outputTarget: NodeOutputTarget,
    outputMapping: WebglOutputMapping,
    keepSourcePrelude: boolean=false,
  ) {
    const outputs = source.outputsFor(outputTarget);
    const newOutputs: WebglOutputs = Object.fromEntries(
      [...objectSymbolEntries(outputs)]
          .map(([key, template]) => [key, template!.substitute(source.template.substitutions)])
    );
    const substitutions = WebglTemplate.substitutionsUsingOutputs(newOutputs, outputMapping);

    return keepSourcePrelude
        ? this.prependPrelude(source.preludeTemplate)
            .prependUniforms(source.uniforms)
            .substitute(substitutions)
        : this.substitute(substitutions);
  }

  prependPrelude(prelude: WebglTemplate) {
    return new WebglVariables(
      this.node,
      this.template,
      WebglTemplate.merge(prelude, this.preludeTemplate),
      this.uniforms,
      this.functionInputDependencies,
      this.fieldOutputs,
    );
  }

  prependUniforms(uniforms: WebglVariables["uniforms"]) {
    return new WebglVariables(
      this.node,
      this.template,
      this.preludeTemplate,
      new Map([...uniforms, ...this.uniforms]),
      this.functionInputDependencies,
      this.fieldOutputs,
    );
  }

  /**
   * Assigns random GLSL variable names to slots named with a number up to `nSlots`
   * @param nSlots 
   * @returns 
   */
  private nameOutputSlots() {
    return this.substitute(
      new Map([...this.outputSlots()].map(slot => [slot, slot.randomVariableName()])),
    );
  }

  private outputSlots() {
    return new Set<WebglSlot>([
      ...this.template.getOutputSlots(),
      ...[...this.uniforms.keys()].flatMap(template => template.getOutputSlots()),
      ...[...this.functionInputDependencies.keys()].flatMap(template => template.getOutputSlots()),
    ]);
  }

  /**
   * Iterates through the nodes which the given node `node` depends on, generating code segment templates for each
   * node. Each node's code segment has its slots filled by the outputs of the nodes before it in the dependency
   * tree.
   * @param node 
   * @returns 
   */
  private static getTranspiledNodeDependencies(node: Node) {
    const dependencyIndices = new Map<Node, number>();
    const dependencies: WebglVariables[] = [];
    const dependencyFields = new Map<InSocket, WebglVariables>();

    let i = 0;
    for (const dependencyNode of node.toposortedDependencies()) {
      let variables = dependencyNode.webglBaseVariables();

      const functionDependencySockets = new Set<OutSocket>();

      for (const [functionName, srcSocket] of variables.functionInputDependencies) {
        functionDependencySockets.add(srcSocket);
        const preludeFunction = this.getAuxiliaryFunction(srcSocket, functionName.toString(), dependencies, dependencyIndices.get(srcSocket.node)!);

        variables = variables.prependPrelude(preludeFunction);
      }

      for (const socket of dependencyNode.ins) {
        const outputMapping = socket.webglGetOutputMapping();
        if (outputMapping === null) continue;

        if (!socket.hasLinks) {
          if (!dependencyFields.has(socket)) {
            dependencyFields.set(socket, socket.webglFieldVariables());
          }

          variables = variables.substituteUsingOutputs(
            dependencyFields.get(socket)!.fieldOutputs,
            outputMapping,
          );
        } else {
          if (functionDependencySockets.has(socket.link.src)) continue;
          
          const srcNode = socket.link.srcNode;
          const srcIndex = dependencyIndices.get(srcNode)!;
          variables = variables.substituteUsingOutputsFrom(
            dependencies[srcIndex],
            NodeOutputTarget.OutSocket(socket.link.src),
            outputMapping,
          );
        }
      }

      dependencies[i] = variables;
      dependencyIndices.set(dependencyNode, i);

      i++;
    }

    const dependenciesIncludingFields = [...dependencyFields.values(), ...dependencies];

    const uniforms: Record<string, UniformInitializer> = {};
    for (const segment of dependenciesIncludingFields) {
      for (const [uniformName, initializer] of segment.uniforms) {
        uniforms[uniformName.toString()] = initializer;
      }
    }

    return {
      dependencies: dependenciesIncludingFields,
      uniforms,
    };
  }

  private static getAuxiliaryFunctionTemplates(socket: Socket): {
    outputTypeValue: string,
    outputTemplate: WebglTemplate,
    mapping: WebglOutputMapping,
  } {
    switch (socket.type) {
      case SocketType.ColorCoords: {
        const {val, illuminant, xyz} = WebglSlot.ins("val", "illuminant", "xyz");

        return {
          outputTypeValue: "Color",
          outputTemplate: WebglTemplate.source`Color(${val}, ${illuminant}, ${xyz})`,
          mapping: {
            [webglOuts.val]: val,
            [webglOuts.illuminant]: illuminant,
            [webglOuts.xyz]: xyz,
          },
        };
      }

      case SocketType.Vector:
      case SocketType.VectorOrColor: {
        const val = WebglSlot.in("val");

        return {
          outputTypeValue: "vec3",
          outputTemplate: WebglTemplate.source`${val}`,
          mapping: {
            [webglOuts.val]: val,
          },
        };
      }

      case SocketType.Float: {
        const val = WebglSlot.in("val");

        return {
          outputTypeValue: "float",
          outputTemplate: WebglTemplate.source`${val}`,
          mapping: {
            [webglOuts.val]: val,
          },
        };
      }
      
      default:
        throw new Error("unsupported type");
    }
  }

  /**
   * Using precomputed segments from `getTranspiledNodeDepencies`, generates a `WebglTemplate` that provides an
   * auxiliary function for the node specified by `nodeIndex`
   * @param socket 
   * @param functionNameValue 
   * @param segments 
   * @param nodeIndex 
   * @returns 
   */
  private static getAuxiliaryFunction(socket: OutSocket, functionNameValue: string, segments: WebglVariables[], nodeIndex: number): WebglTemplate {
    const {outputTypeValue, outputTemplate, mapping} = this.getAuxiliaryFunctionTemplates(socket);

    const relevantSegments = segments.slice(0, nodeIndex + 1);

    return WebglVariables.auxiliaryFunctionTemplate.substituteInputs(
      ({main, outputType, functionName, functionOutput}) => new Map([
        [main, relevantSegments.map(segment => segment.template.toString())
            .join("\n\n")],
        // no need to copy prelude/uniforms because uniforms will be shared with the primary function
        [functionOutput, outputTemplate.substituteUsingOutputs(
          segments[nodeIndex].outputsFor(NodeOutputTarget.OutSocket(socket)),
          mapping,
        ).toString()],
        [outputType, outputTypeValue],
        [functionName, functionNameValue],
      ]),
    );
  }

  /**
   * Generates WebGL source code that computes the output of node `node`.
   * @param node 
   * @returns 
   */
  static transpileNodeOutput(node: Node) {
    const {dependencies, uniforms} = this.getTranspiledNodeDependencies(node);

    // console.log(segments.map(segment => segment.template)
    //     .join("\n\n"));
    // console.log(segments.map(segment => segment.preludeTemplate)
    //     .join("\n"));
    // console.log(uniforms);

    const lastDependency = dependencies.at(-1)!;
    const lastDependencySubstitutions = lastDependency.template.substitutions;
    const lastDependencytNodeOutputs = lastDependency.node?.webglOutputs();

    return new WebglTranspilation(
      WebglVariables.fragmentShaderTemplate.substituteInputs(
        ({main, val, xyz, illuminant, prelude, alpha}) => new Map([
          [main, dependencies.map(segment => segment.template.toString())
              .join("\n\n")],
          [val, lastDependencytNodeOutputs?.[webglOuts.val]?.substitute(lastDependencySubstitutions).toString() ?? "vec3(0., 0., 0.)"],
          [xyz, lastDependencytNodeOutputs?.[webglOuts.xyz]?.substitute(lastDependencySubstitutions).toString() ?? "vec3(0., 0., 0.)"],
          [illuminant, lastDependencytNodeOutputs?.[webglOuts.illuminant]?.substitute(lastDependencySubstitutions).toString() ?? "illuminant2_D65"],
          [alpha, lastDependencytNodeOutputs?.[webglOuts.alpha]?.substitute(lastDependencySubstitutions).toString() ?? "1."],
          [prelude, dependencies.map(segment => segment.preludeTemplate.toString())
              .join("\n")],
        ]),
      ).toString(),
      uniforms,
    );
  }

  private outputsFor(target: NodeOutputTarget) {
    return target.match({
      onSocket: socket => socket.webglOutputs(),
      onNode: node => node.webglOutputs(),
      onField: () => this.fieldOutputs,
    });
  }

  static fromTemplate(template: WebglTemplate) {
    return ({
      node,
      preludeTemplate=WebglTemplate.empty(),
      uniforms=new Map(),
      functionInputDependencies=new Map(),
      fieldOutputs={},
    }: {
      node: Node | null,
      preludeTemplate?: WebglVariables["preludeTemplate"],
      uniforms?: WebglVariables["uniforms"],
      functionInputDependencies?: WebglVariables["functionInputDependencies"],
      fieldOutputs?: WebglOutputs,
    }) => {
      return new WebglVariables(
        node,
        template,
        preludeTemplate,
        uniforms,
        functionInputDependencies,
        fieldOutputs,
      ).nameOutputSlots();
    };
  }

  static template(strings: TemplateStringsArray, ...slots: WebglSlot[]) {
    return this.fromTemplate(WebglTemplate.source(strings, ...slots));
  }

  static templateConcat(strings: TemplateStringsArray, ...items: (WebglSlot | WebglTemplate | string)[]) {
    return this.fromTemplate(WebglTemplate.concat(strings, ...items));
  }

  static empty(options: Parameters<ReturnType<typeof WebglVariables["fromTemplate"]>>[0]) {
    return this.template``(options);
  }
}

export class WebglTranspilation {
  constructor(
    readonly shaderSource: string,
    private readonly uniforms: Record<string, UniformInitializer>,
  ) {}

  initializeUniforms(gl: WebGL2RenderingContext, program: WebGLProgram): UniformReloadData {
    const textureIdMap = new Map<WebGLUniformLocation, number>();
    const socketDependents = new Map<InSocket, string[]>();
    const nodeDependents = new Map<Node, string[]>();

    let nUsedTextures = 0;
    for (const [unifName, {set: initializeUnif, dependencySockets, dependencyNodes}] of Object.entries(this.uniforms)) {
      const unif = gl.getUniformLocation(program, unifName)!;

      const usedTexture = initializeUnif(gl, unif, nUsedTextures);

      if (usedTexture) {
        textureIdMap.set(unif, nUsedTextures);
        nUsedTextures++;
      }

      for (const socket of dependencySockets) {
        if (socketDependents.has(socket)) {
          socketDependents.get(socket)!.push(unifName);
        } else {
          socketDependents.set(socket, [unifName]);
        }
      }

      for (const node of dependencyNodes) {
        if (nodeDependents.has(node)) {
          nodeDependents.get(node)!.push(unifName);
        } else {
          nodeDependents.set(node, [unifName]);
        }
      }
    }

    return {
      textureIdMap,
      socketDependents,
      nodeDependents,
    };
  }

  refreshUniforms(
    gl: WebGL2RenderingContext,
    program: WebGLProgram,
    updateSource: NodeUpdateSource,
    uniformData: UniformReloadData,
  ) {

    const dependents = 
        updateSource.socket.mapElse(
          socket => uniformData.socketDependents.get(socket) ?? [],
          () => updateSource.node.mapElse(
            node => uniformData.nodeDependents.get(node) ?? [],
            () => {
              throw new TypeError();
            },
          ),
        );

    for (const unifName of dependents) {
      const {set: initializeUnif} = this.uniforms[unifName];

      const unif = gl.getUniformLocation(program, unifName)!;

      if (uniformData.textureIdMap.has(unif!)) {
        initializeUnif(gl, unif, uniformData.textureIdMap.get(unif)!);
      } else {
        initializeUnif(gl, unif, 0);
      }
    }
  }
}

export type UniformReloadData = {
  textureIdMap: Map<WebGLUniformLocation, number>,
  socketDependents: Map<InSocket, string[]>,
  nodeDependents: Map<Node, string[]>,
};